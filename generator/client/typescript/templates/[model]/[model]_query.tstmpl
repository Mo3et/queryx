// Code generated by queryx, DO NOT EDIT.

import { QXClient, SelectStatement, newInsert, Clause } from "../queryx";
import { {{ $.model.Name }} } from "./{{ $.model.Name | snake }}";
import { {{ $.model.Name }}Change, {{ $.model.Name }}ChangeInput } from "./{{ $.model.Name | snake }}_change";

export class {{ $.model.Name }}Query {
  private client: QXClient;
  private selectStatement: SelectStatement;

  constructor(client: QXClient) {
    this.client = client;
    this.selectStatement = new SelectStatement();
    this.selectStatement.select("{{ $.model.TableName }}.*").from("{{ $.model.TableName }}");
  }

  async create(input: {{ $.model.Name }}ChangeInput) {
    let change = new {{ $.model.Name }}Change(input);
    {{- if $.model.Timestamps }}
    const now = new Date().toISOString();
    if(change.createdAt === undefined) {
      change.setCreatedAt(now);
    }
    if (change.updatedAt === undefined) {
      change.setUpdatedAt(now);
    }
    {{- end }}

    let [columns, values] = change.changes();
    let [query, args] = newInsert()
      .into("{{ $.model.TableName }}")
      .columns(...columns)
      .values(...values)
      .returning("{{ range $i, $e := $.model.Columns}}{{if $i}},{{end}}{{.Name}}{{end}}")
      .toSQL();

    let row = await this.client.queryOne(query, ...args);
    let record = new {{ $.model.Name }}(this.client);

    {{- range $c := $.model.Columns }}
    record.{{ $c.Name | camel }} = row.{{ $c.Name }};
    {{- end }}

    return record;
  }

  async find(id: number | BigInt) {
    let record = new {{ $.model.Name }}(this.client);
    let row = await this.where(this.client.{{ $.model.Name | camel }}ID.eq(id)).first();
    {{- range $c := $.model.Columns }}
    record.{{ $c.Name | camel }} = row.{{ $c.Name }};
    {{- end }}
    return record;
  }

  async findBy() {}

  async findBySQL() {}

  where(clause: Clause) {
    this.selectStatement.where(clause)
    return this;
  }

  select() {}

  limit(limit: number) {
    this.selectStatement.limit(limit)
    return this;
  }

  offset() {}

  group() {}

  having() {}

  joins() {}

  order() {}

  {{- range $b := $.model.BelongsTo }}
  preload{{ pascal $b.Name }}() {}
  {{- end }}

  {{- range $h := $.model.HasMany }}
  preload{{ pascal $h.Name }}() {}
  {{- end }}

  {{- range $h := $.model.HasOne }}
  preload{{ pascal $h.Name }}() {}
  {{- end }}

  async all() {
    let [query, args] = this.selectStatement.toSQL();
    let rows = await this.client.query(query, ...args);
    let records: {{ $.model.Name }}[] = [];
    for (let row of rows) {
      let record = new {{ $.model.Name }}(this.client);
      {{- range $c := $.model.Columns }}
      record.{{ $c.Name | camel }} = row.{{ $c.Name }};
      {{- end }}
      records.push(record);
    }
    return records;
  }

  async first() {
    this.limit(1);
    let records = await this.all();
    return records[0];
  }

  async count() {
    this.selectStatement.select("COUNT(*)");
    let [query, args] = this.selectStatement.toSQL();
    let res = await this.client.queryOne(query, ...args);
    return res.count as BigInt;
  }

  async exists() {
    this.selectStatement.select("1 AS one").limit(1);
    let [query, args] = this.selectStatement.toSQL();
    let res = await this.client.queryOne(query, ...args);
    return res;
  }

  async updateAll(input: {{ $.model.Name }}ChangeInput) {
    let change = new {{ $.model.Name }}Change(input);
    let [columns, values] = change.changes();
    let [query, args] = this.selectStatement
      .update()
      .columns(...columns)
      .values(...values)
      .toSQL();
    let res = await this.client.exec(query, ...args);
    return res;
  }

  async deleteAll() {
    let [query, args] = this.selectStatement.delete().toSQL();
    let res = await this.client.exec(query, ...args);
    return res;
  }
}

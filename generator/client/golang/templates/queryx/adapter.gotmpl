// Code generated by queryx, DO NOT EDIT.

package queryx

import (
	"database/sql"
	"regexp"

	{{- if eq $.client.Adapter "postgresql" }}
	_ "github.com/lib/pq"
	{{- else if eq $.client.Adapter "mysql" }}
	_ "github.com/go-sql-driver/mysql"
	{{- else if eq $.client.Adapter "sqlite"  }}
	_ "github.com/mattn/go-sqlite3"
	{{- end }}
)

type DB interface {
	Exec(query string, args ...interface{}) (sql.Result, error)
	Query(query string, args ...interface{}) (*sql.Rows, error)
}

type Adapter struct {
	db DB
}

func NewAdapter(db DB) *Adapter {
	return &Adapter{db: db}
}

{{- if or (eq $.client.Adapter "postgresql") (eq $.client.Adapter "sqlite") }}
func (a *Adapter) Exec(query string, args ...interface{}) (int64, error) {
	matched1, err := regexp.MatchString(`.* IN (.*?)`, query)
	if err != nil {
		return 0, err
	}
	matched2, err := regexp.MatchString(`.* in (.*?)`, query)
	if err != nil {
		return 0, err
	}
	if matched1 || matched2 {
		query, args, err = In(query, args...)
		if err != nil {
			return 0, err
		}
	}
	result, err := a.db.Exec(rebind(DOLLAR, query), args...)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
{{- else if eq $.client.Adapter "mysql" }}
func (a *Adapter) Exec(query string, args ...interface{}) (sql.Result, error) {
	matched1, err := regexp.MatchString(`.* IN (.*?)`, query)
	if err != nil {
		return nil, err
	}
	matched2, err := regexp.MatchString(`.* in (.*?)`, query)
	if err != nil {
		return nil, err
	}
	if matched1 || matched2 {
		query, args, err = In(query, args...)
		if err != nil {
			return nil, err
		}
	}
	result, err := a.db.Exec(query, args...)
	if err != nil {
		return nil, err
	}
	return result, err
}
{{- end}}


func (a *Adapter) Query(query string, args ...interface{}) *Rows {
	return &Rows{
		adapter: a,
		query:   query,
		args:    args,
	}
}

type Rows struct {
	adapter *Adapter
	query   string
	args    []interface{}
	err     error
}

func (r *Rows) Scan(v interface{}) error {
	if r.err != nil {
		return r.err
	}
	var err error
	query, args := r.query, r.args
	matched1, err := regexp.MatchString(`.* IN (.*?)`, query)
	if err != nil {
		return err
	}
	matched2, err := regexp.MatchString(`.* in (.*?)`, query)
	if err != nil {
		return err
	}
	if matched1 || matched2 {
		query, args, err = In(query, args...)
		if err != nil {
			return err
		}
	}
	{{- if eq $.client.Adapter "postgresql" }}
	rows, err := r.adapter.db.Query(rebind(DOLLAR, query), args...)
	{{- else if or (eq $.client.Adapter "mysql") (eq $.client.Adapter "sqlite") }}
	rows, err := r.adapter.db.Query(query, args...)
	{{- end}}
	if err != nil {
		return err
	}
	err = ScanSlice(rows, v)
	if err != nil {
		return err
	}
	return err
}

type Row struct {
	adapter *Adapter
	query   string
	args    []interface{}
}

func (r *Row) Scan(v interface{}) error {
	query, args := r.query, r.args
	matched1, err := regexp.MatchString(`.* IN (.*?)`, query)
	if err != nil {
		return err
	}
	matched2, err := regexp.MatchString(`.* in (.*?)`, query)
	if err != nil {
		return err
	}
	if matched1 || matched2 {
		query, args, err = In(query, args...)
		if err != nil {
			return err
		}
	}
    {{- if eq $.client.Adapter "postgresql" }}
    rows, err := r.adapter.db.Query(rebind(DOLLAR, query), args...)
    {{- else if or (eq $.client.Adapter "mysql") (eq $.client.Adapter "sqlite") }}
    rows, err := r.adapter.db.Query(query, args...)
    {{- end}}
	if err != nil {
		return err
	}
	err = ScanOne(rows, v)
	if err != nil {
		return err
	}
	return err
}

func (a *Adapter) QueryOne(query string, args ...interface{}) *Row {
	return &Row{
		adapter: a,
		query:   query,
		args:    args,
	}
}
